[[plugins]]
repo="neovim/nvim-lspconfig"
on_cmd="LspInfo"
on_source="mason.nvim"

[[plugins]]
repo="williamboman/mason-lspconfig.nvim"
on_cmd=['LspInstall', 'LspUninstall']
on_source="mason.nvim"

[[plugins]]
repo="williamboman/mason.nvim"
on_event = ['BufNewFile', 'BufRead']
depends=['mason-lspconfig.nvim', 'nvim-lspconfig']
lua_source='''
---@diagnostic disable: redefined-local
local status, mason = pcall(require, "mason")
local nvim_lsp = require("lspconfig")
if not status then
	return
end

mason.setup({
	ui = {
		icons = {
			package_installed = "✓",
			package_pending = "➜",
			package_uninstalled = "✗",
		},
	},
})

local opts = { noremap = true, silent = true }

-- add lsp
local servers = { "pyright", "lua_ls", "texlab", "clangd", "html", "rust_analyzer" }
local status, mason_lspconfig = pcall(require, "mason-lspconfig")
if not status then
	return
end

mason_lspconfig.setup({ ensure_installed = servers })

local status, lspconfig = pcall(require, "lspconfig")
if not status then
	return
end

local handlers = {
	function(server_name)
		local node_root_dir = nvim_lsp.util.root_pattern("package.json")
		local is_node_repo = node_root_dir(vim.api.nvim_buf_get_name(0)) ~= nil
		local opts = {}
		if server_name == "tsserver" then
			if not is_node_repo then
				return
			end
		elseif server_name == "eslint" then
			if not is_node_repo then
				return
			end
		elseif server_name == "denols" then
			if is_node_repo then
				return
			end
		end
		opts.root_dir = nvim_lsp.util.root_pattern("deno.json", 'deno.jsonc', 'deps.ts', 'import_map.json')
		opts.init_options = {
			lint = true,
			unstable = true,
			suggest = {
				imports = {
					hosts = {
						["https://deno.land"] = true,
						["https://cdn.nest.land"] = true,
						["https://crux.land"] = true
					}
				}
			}
		}
		lspconfig[server_name].setup(opts)
	end,
}
mason_lspconfig.setup_handlers(handlers)
-- -- LSP handlers
vim.diagnostic.config({ virtual_text = false })
vim.lsp.handlers["textDocument/publishDiagnostics"] =
	vim.lsp.with(vim.lsp.diagnostic.on_publish_diagnostics, { virtual_text = false })

vim.api.nvim_create_autocmd("LspAttach", {
	group = vim.api.nvim_create_augroup("UserLspConfig", {}),
	callback = function(ev)
		-- Enable completion triggered by <c-x><c-o>
		vim.bo[ev.buf].omnifunc = "v:lua.vim.lsp.omnifunc"
		local opt = { noremap = true, silent = true, buffer = ev.buf }
		-- Mappings.
		-- See `:help vim.lsp.*` for documentation on any of the below functions
		vim.keymap.set("n", "gD", vim.lsp.buf.declaration, opt)
		vim.keymap.set("n", "gd", vim.lsp.buf.definition, opt)
		vim.keymap.set("n", "gi", vim.lsp.buf.implementation, opt)
		vim.keymap.set("n", "gr", vim.lsp.buf.references, opt)
		vim.keymap.set("n", "H", vim.lsp.buf.hover, opt)
		vim.keymap.set("n", "K", vim.lsp.buf.type_definition, opt)
		vim.keymap.set("n", "<Leader>D", vim.lsp.buf.type_definition, opt)
		vim.keymap.set("n", "<Leader>rn", vim.lsp.buf.rename, opt)
		vim.keymap.set("n", "<Leader>bf", "<cmd>lua vim.lsp.buf.format({async=true})<CR>", opt)
		vim.keymap.set("n", "<Leader>ic", vim.lsp.buf.incoming_calls, opt)
		vim.keymap.set("n", "[e", vim.diagnostic.goto_next, opt)
		vim.keymap.set("n", "]e", vim.diagnostic.goto_prev, opt)
		vim.keymap.set("n", "<Leader>e", vim.diagnostic.open_float, opts)
		-- Reference highlight
		local client = vim.lsp.get_client_by_id(ev.data.client_id)
		if client.server_capabilities.documentFormattingProvider then
			vim.api.nvim_create_autocmd({ "BufWritePre" }, {
				buffer = bufnr,
				callback = function()
					vim.lsp.buf.format({ timeout_ms = 2500 })
				end,
			})
		end
		if client.server_capabilities.documentHighlightProvider then
			vim.api.nvim_command(
				"highlight LspReferenceText  cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command(
				"highlight LspReferenceRead  cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command(
				"highlight LspReferenceWrite cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command("set updatetime=100")
			vim.api.nvim_create_augroup("lsp_document_highlight", { clear = true })
			vim.api.nvim_clear_autocmds({
				buffer = ev.buf,
				group = "lsp_document_highlight",
			})
			vim.api.nvim_create_autocmd("CursorHold", {
				callback = vim.lsp.buf.document_highlight,
				buffer = ev.buf,
				group = "lsp_document_highlight",
				desc = "Document Highlight",
			})
			vim.api.nvim_create_autocmd("CursorMoved", {
				callback = vim.lsp.buf.clear_references,
				buffer = ev.buf,
				group = "lsp_document_highlight",
				desc = "Clear All the References",
			})
		end
	end,
})
vim.api.nvim_create_autocmd("CursorHold", {
	callback = function()
		vim.diagnostic.open_float({ focus = false })
	end,
})
vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, {
	border = "single", -- "shadow" , "none", "rounded"
})
'''

[[plugins]]
repo="nvimtools/none-ls.nvim"
on_event = ['BufNewFile', 'BufRead']
lua_source='''
local status, null_ls = pcall(require, "null-ls")
if not status then
	return
end

local augroup = vim.api.nvim_create_augroup("LspFormatting", {})

local on_attach = function(client, bufnr)
	-- you can reuse a shared lspconfig on_attach callback here
	if client.supports_method("textDocument/formatting") then
		vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr })
		vim.api.nvim_create_autocmd("BufWritePre", {
			group = augroup,
			buffer = bufnr,
			callback = function()
				vim.lsp.buf.format({ bufnr = bufnr })
			end,
		})
	end
end

-- add
local status, mason_package = pcall(require, "mason-core.package")
if not status then
	return
end
local status, mason_registry = pcall(require, "mason-registry")
if not status then
	return
end

local null_sources = {}

for _, package in ipairs(mason_registry.get_installed_packages()) do
	local package_categories = package.spec.categories[1]
	if package_categories == mason_package.Cat.Formatter then
		-- prettier をMarkdownで動作させないようにする
		if package.name == "prettier" then
			local source = null_ls.builtins.formatting[package.name]
			source.disabled_filetypes = { "markdown" }
			table.insert(null_sources, source)
		else
			table.insert(null_sources, null_ls.builtins.formatting[package.name])
		end
	end
	if package_categories == mason_package.Cat.Linter then
		table.insert(null_sources, null_ls.builtins.diagnostics[package.name])
	end
end

null_ls.setup({ debug = false, sources = null_sources, on_attach = on_attach })
'''

[[plugins]]
repo="onsails/lspkind-nvim"
lua_source='''
	local status, lspkind = pcall(require, "lspkind")
	if not status then
		return
	end

	lspkind.init({
		-- enables text annotations
		--
		-- default: true
		mode = "symbol_text",
		-- default symbol map
		-- can be either 'default' (requires nerd-fonts font) or
		-- 'codicons' for codicon preset (requires vscode-codicons font)
		--
		-- default: 'default'
		preset = "codicons",
		-- override preset symbols
		--
		-- default: {}
		symbol_map = {
			Text = "",
			Method = "",
			Function = "",
			Constructor = "",
			Field = "ﰠ",
			Variable = "",
			Class = "ﴯ",
			Interface = "",
			Module = "",
			Property = "ﰠ",
			Unit = "塞",
			Value = "",
			Enum = "",
			Keyword = "",
			Snippet = "",
			Color = "",
			File = "",
			Reference = "",
			Folder = "",
			EnumMember = "",
			Constant = "",
			Struct = "פּ",
			Event = "",
			Operator = "",
			TypeParameter = "",
			Copilot = "",
		},
	})
'''
