[[plugins]]
repo = "neovim/nvim-lspconfig"
on_cmd = "LspInfo"
on_source = ["mason.nvim", "ddc.vim"]

[[plugins]]
repo = "williamboman/mason-lspconfig.nvim"
on_cmd = ['LspInstall', 'LspUninstall']
on_source = "mason.nvim"

[[plugins]]
repo = "williamboman/mason.nvim"
on_event = ['BufNewFile', 'BufRead']
depends = ['mason-lspconfig.nvim', 'nvim-lspconfig']
lua_source='''
---@diagnostic disable: redefined-local
local mason = require("mason")

mason.setup({
	ui = {
		icons = {
			package_installed = "✓",
			package_pending = "➜",
			package_uninstalled = "✗",
		},
	},
})

local opts = { noremap = true, silent = true }

-- add lsp
local status, mason_lspconfig = pcall(require, "mason-lspconfig")
if not status then
	return
end

-- mason_lspconfig.setup()
local nvim_lsp = require("lspconfig")
local handlers = {
	function(server_name)
		nvim_lsp[server_name].setup(opts)
	end,
}
mason_lspconfig.setup_handlers(handlers)
-- LSP handlers
vim.diagnostic.config({ virtual_text = false }) vim.lsp.handlers["textDocument/publishDiagnostics"] =
	vim.lsp.with(vim.lsp.diagnostic.on_publish_diagnostics, { virtual_text = false })

vim.api.nvim_create_autocmd("LspAttach", {
	group = vim.api.nvim_create_augroup("UserLspConfig", {}),
	callback = function(ev)
		-- Enable completion triggered by <c-x><c-o>
		vim.bo[ev.buf].omnifunc = "v:lua.vim.lsp.omnifunc"
		local opt = { noremap = true, silent = true, buffer = ev.buf }
		-- Mappings.
		-- See `:help vim.lsp.*` for documentation on any of the below functions
		vim.keymap.set("n", "gD", vim.lsp.buf.declaration, opt)
		vim.keymap.set("n", "gd", vim.lsp.buf.definition, opt)
		vim.keymap.set("n", "gi", vim.lsp.buf.implementation, opt)
		vim.keymap.set("n", "gr", vim.lsp.buf.references, opt)
		vim.keymap.set("n", "H", vim.lsp.buf.hover, opt)
		vim.keymap.set("n", "K", vim.lsp.buf.type_definition, opt)
		vim.keymap.set("n", "<Leader>D", vim.lsp.buf.type_definition, opt)
		vim.keymap.set("n", "<Leader>rn", vim.lsp.buf.rename, opt)
		vim.keymap.set("n", "<Leader>bf", "<cmd>lua vim.lsp.buf.format({async=true})<CR>", opt)
		vim.keymap.set("n", "<Leader>ic", vim.lsp.buf.incoming_calls, opt)
		vim.keymap.set("n", "[e", vim.diagnostic.goto_next, opt)
		vim.keymap.set("n", "]e", vim.diagnostic.goto_prev, opt)
		vim.keymap.set("n", "<Leader>e", vim.diagnostic.open_float, opts)
		-- Reference highlight
		local client = vim.lsp.get_client_by_id(ev.data.client_id)
		if client.server_capabilities.documentFormattingProvider then
			vim.api.nvim_create_autocmd({ "BufWritePre" }, {
				buffer = bufnr,
				callback = function()
					vim.lsp.buf.format({ timeout_ms = 2500 })
				end,
			})
		end
		if client.server_capabilities.documentHighlightProvider then
			vim.api.nvim_command(
				"highlight LspReferenceText  cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command(
				"highlight LspReferenceRead  cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command(
				"highlight LspReferenceWrite cterm=underline ctermbg=8 gui=underline guibg=#104040"
			)
			vim.api.nvim_command("set updatetime=100")
			vim.api.nvim_create_augroup("lsp_document_highlight", { clear = true })
			vim.api.nvim_clear_autocmds({
				buffer = ev.buf,
				group = "lsp_document_highlight",
			})
			vim.api.nvim_create_autocmd("CursorHold", {
				callback = vim.lsp.buf.document_highlight,
				buffer = ev.buf,
				group = "lsp_document_highlight",
				desc = "Document Highlight",
			})
			vim.api.nvim_create_autocmd("CursorMoved", {
				callback = vim.lsp.buf.clear_references,
				buffer = ev.buf,
				group = "lsp_document_highlight",
				desc = "Clear All the References",
			})
		end
	end,
})
vim.api.nvim_create_autocmd("CursorHold", {
	callback = function()
		vim.diagnostic.open_float({ focus = false })
	end,
})
vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, {
	border = "single", -- "shadow" , "none", "rounded"
})
'''

[[plugins]]
repo = "nvimtools/none-ls.nvim"
on_event = ['BufNewFile', 'BufRead']
depends='mason.nvim'
lua_source = '''
local status, null_ls = pcall(require, "null-ls")
if not status then
	return
end

local augroup = vim.api.nvim_create_augroup("LspFormatting", {})

local on_attach = function(client, bufnr)
	-- you can reuse a shared lspconfig on_attach callback here
	if client.supports_method("textDocument/formatting") then
		vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr })
		vim.api.nvim_create_autocmd("BufWritePre", {
			group = augroup,
			buffer = bufnr,
			callback = function()
				vim.lsp.buf.format({ bufnr = bufnr })
			end,
		})
	end
end

-- add
local status, mason_package = pcall(require, "mason-core.package")
if not status then
	return
end
local status, mason_registry = pcall(require, "mason-registry")
if not status then
	return
end

local null_sources = {}

for _, package in ipairs(mason_registry.get_installed_packages()) do
	local package_categories = package.spec.categories[1]
	if package_categories == mason_package.Cat.Formatter then
		-- prettier をMarkdownで動作させないようにする
		if package.name == "prettier" then
			local source = null_ls.builtins.formatting[package.name]
			source.disabled_filetypes = { "markdown" }
			table.insert(null_sources, source)
		else
			table.insert(null_sources, null_ls.builtins.formatting[package.name])
		end
	end
	if package_categories == mason_package.Cat.Linter then
		table.insert(null_sources, null_ls.builtins.diagnostics[package.name])
	end
end

null_ls.setup({ debug = false, sources = null_sources, on_attach = on_attach })
'''
